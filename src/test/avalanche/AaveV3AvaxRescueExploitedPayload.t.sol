// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import {AaveV3Avalanche, AaveV3AvalancheAssets} from 'aave-address-book/AaveV3Avalanche.sol';
import {AaveV3AvaxRescueExploitedPayload} from '../../contracts/avalanche/AaveV3AvaxRescueExploitedPayload.sol';
import {TestWithExecutor} from 'aave-helpers/GovHelpers.sol';
import {IERC20} from 'solidity-utils/contracts/oz-common/interfaces/IERC20.sol';

contract AaveV3AvaxRescueExploitedPayloadTest is TestWithExecutor {
  struct TokenBalances {
    uint256 USDC;
    uint256 USDT;
    uint256 DAI;
    uint256 BUSD;
    uint256 USP;
    uint256 USDCBridged;
    uint256 USDTBridged;
  }

  AaveV3AvaxRescueExploitedPayload public proposalPayload;

  function setUp() public {
    vm.createSelectFork(vm.rpcUrl('avalanche'), 27456217);
    _selectPayloadExecutor(AaveV3Avalanche.ACL_ADMIN);
  }

  function testRescue() public {
    // 1. deploy l2 payload
    proposalPayload = new AaveV3AvaxRescueExploitedPayload();

    TokenBalances memory poolBalanceBefore;
    TokenBalances memory poolBalanceAfter;
    TokenBalances memory recipientBalanceBefore;
    TokenBalances memory recipientBalanceAfter;

    // Get token balances of pool before payload execution
    poolBalanceBefore.USDC = IERC20(AaveV3AvalancheAssets.USDC_UNDERLYING).balanceOf(
      address(AaveV3Avalanche.POOL)
    );
    poolBalanceBefore.USDCBridged = IERC20(proposalPayload.USDC_BRIDGED()).balanceOf(
      address(AaveV3Avalanche.POOL)
    );
    poolBalanceBefore.USDT = IERC20(AaveV3AvalancheAssets.USDt_UNDERLYING).balanceOf(
      address(AaveV3Avalanche.POOL)
    );
    poolBalanceBefore.USDTBridged = IERC20(proposalPayload.USDT_BRIDGED()).balanceOf(
      address(AaveV3Avalanche.POOL)
    );
    poolBalanceBefore.DAI = IERC20(AaveV3AvalancheAssets.DAIe_UNDERLYING).balanceOf(
      address(AaveV3Avalanche.POOL)
    );
    poolBalanceBefore.BUSD = IERC20(proposalPayload.BUSD()).balanceOf(
      address(AaveV3Avalanche.POOL)
    );
    poolBalanceBefore.USP = IERC20(proposalPayload.USP()).balanceOf(
      address(AaveV3Avalanche.POOL)
    );

    // Get token balances of recipient before payload execution
    recipientBalanceBefore.USDC = IERC20(AaveV3AvalancheAssets.USDC_UNDERLYING).balanceOf(
      proposalPayload.PLATYPUS_MULTISIG()
    );
    recipientBalanceBefore.USDCBridged = IERC20(proposalPayload.USDC_BRIDGED()).balanceOf(
      proposalPayload.PLATYPUS_MULTISIG()
    );
    recipientBalanceBefore.USDT = IERC20(AaveV3AvalancheAssets.USDt_UNDERLYING).balanceOf(
      proposalPayload.PLATYPUS_MULTISIG()
    );
    recipientBalanceBefore.USDTBridged = IERC20(proposalPayload.USDT_BRIDGED()).balanceOf(
      proposalPayload.PLATYPUS_MULTISIG()
    );
    recipientBalanceBefore.DAI = IERC20(AaveV3AvalancheAssets.DAIe_UNDERLYING).balanceOf(
      proposalPayload.PLATYPUS_MULTISIG()
    );
    recipientBalanceBefore.BUSD = IERC20(proposalPayload.BUSD()).balanceOf(
      proposalPayload.PLATYPUS_MULTISIG()
    );
    recipientBalanceBefore.USP = IERC20(proposalPayload.USP()).balanceOf(
      proposalPayload.PLATYPUS_MULTISIG()
    );

    // 2. execute l2 payload
    _executePayload(address(proposalPayload));

    // Get token balances of pool after payload execution
    poolBalanceAfter.USDC = IERC20(AaveV3AvalancheAssets.USDC_UNDERLYING).balanceOf(
      address(AaveV3Avalanche.POOL)
    );
    poolBalanceAfter.USDCBridged = IERC20(proposalPayload.USDC_BRIDGED()).balanceOf(
      address(AaveV3Avalanche.POOL)
    );
    poolBalanceAfter.USDT = IERC20(AaveV3AvalancheAssets.USDt_UNDERLYING).balanceOf(
      address(AaveV3Avalanche.POOL)
    );
    poolBalanceAfter.USDTBridged = IERC20(proposalPayload.USDT_BRIDGED()).balanceOf(
      address(AaveV3Avalanche.POOL)
    );
    poolBalanceAfter.DAI = IERC20(AaveV3AvalancheAssets.DAIe_UNDERLYING).balanceOf(
      address(AaveV3Avalanche.POOL)
    );
    poolBalanceAfter.BUSD = IERC20(proposalPayload.BUSD()).balanceOf(
      address(AaveV3Avalanche.POOL)
    );
    poolBalanceAfter.USP = IERC20(proposalPayload.USP()).balanceOf(
      address(AaveV3Avalanche.POOL)
    );

    // Get token balances of recipient after payload execution
    recipientBalanceAfter.USDC = IERC20(AaveV3AvalancheAssets.USDC_UNDERLYING).balanceOf(
      proposalPayload.PLATYPUS_MULTISIG()
    );
    recipientBalanceAfter.USDCBridged = IERC20(proposalPayload.USDC_BRIDGED()).balanceOf(
      proposalPayload.PLATYPUS_MULTISIG()
    );
    recipientBalanceAfter.USDT = IERC20(AaveV3AvalancheAssets.USDt_UNDERLYING).balanceOf(
      proposalPayload.PLATYPUS_MULTISIG()
    );
    recipientBalanceAfter.USDTBridged = IERC20(proposalPayload.USDT_BRIDGED()).balanceOf(
      proposalPayload.PLATYPUS_MULTISIG()
    );
    recipientBalanceAfter.DAI = IERC20(AaveV3AvalancheAssets.DAIe_UNDERLYING).balanceOf(
      proposalPayload.PLATYPUS_MULTISIG()
    );
    recipientBalanceAfter.BUSD = IERC20(proposalPayload.BUSD()).balanceOf(
      proposalPayload.PLATYPUS_MULTISIG()
    );
    recipientBalanceAfter.USP = IERC20(proposalPayload.USP()).balanceOf(
      proposalPayload.PLATYPUS_MULTISIG()
    );

    // Validate balances of pool
    assertEq(
      poolBalanceBefore.USDC - poolBalanceAfter.USDC,
      proposalPayload.USDC_AMOUNT()
    );
    assertEq(
      poolBalanceBefore.USDCBridged - poolBalanceAfter.USDCBridged,
      proposalPayload.USDC_BRIDGED_AMOUNT()
    );
    assertEq(
      poolBalanceBefore.USDT - poolBalanceAfter.USDT,
      proposalPayload.USDT_AMOUNT()
    );
    assertEq(
      poolBalanceBefore.USDTBridged - poolBalanceAfter.USDTBridged,
      proposalPayload.USDT_BRIDGED_AMOUNT()
    );
    assertEq(
      poolBalanceBefore.DAI - poolBalanceAfter.DAI,
      proposalPayload.DAI_AMOUNT()
    );
    assertEq(
      poolBalanceBefore.BUSD - poolBalanceAfter.BUSD,
      proposalPayload.BUSD_AMOUNT()
    );
    assertEq(
      poolBalanceBefore.USP - poolBalanceAfter.USP,
      proposalPayload.USP_AMOUNT()
    );

    // Validate balances of recipient
    assertEq(
      recipientBalanceAfter.USDC - recipientBalanceBefore.USDC,
      proposalPayload.USDC_AMOUNT()
    );
    assertEq(
      recipientBalanceAfter.USDCBridged - recipientBalanceBefore.USDCBridged,
      proposalPayload.USDC_BRIDGED_AMOUNT()
    );
    assertEq(
      recipientBalanceAfter.USDT - recipientBalanceBefore.USDT,
      proposalPayload.USDT_AMOUNT()
    );
    assertEq(
      recipientBalanceAfter.USDTBridged - recipientBalanceBefore.USDTBridged,
      proposalPayload.USDT_BRIDGED_AMOUNT()
    );
    assertEq(
      recipientBalanceAfter.DAI - recipientBalanceBefore.DAI,
      proposalPayload.DAI_AMOUNT()
    );
    assertEq(
      recipientBalanceAfter.BUSD - recipientBalanceBefore.BUSD,
      proposalPayload.BUSD_AMOUNT()
    );
    assertEq(
      recipientBalanceAfter.USP - recipientBalanceBefore.USP,
      proposalPayload.USP_AMOUNT()
    );
  }
}
